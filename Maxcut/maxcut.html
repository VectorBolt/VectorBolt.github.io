
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Solving the Weighted Maxcut Problem from Scratch with QAOA &#8212; Avneesh Verma&#39;s Personal Website</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=87e54e7c" />
    <link rel="stylesheet" type="text/css" href="../_static/my-style.css?v=f1d1652c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=3ee479438cf8b5e0d341"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Maxcut/maxcut';</script>
    <link rel="icon" href="../_static/VectorBolt Square.jpg"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Quantum Key Distribution (BB84 Protocol)" href="../Quantum%20Key%20Distribution.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../landing-page.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/Happy Headshot.jpg" class="logo__image only-light" alt="Avneesh Verma's Personal Website - Home"/>
    <script>document.write(`<img src="../_static/Happy Headshot.jpg" class="logo__image only-dark" alt="Avneesh Verma's Personal Website - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../landing-page.html">
                    Hi, I’m Avneesh!
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Quantum%20Key%20Distribution.html">Quantum Key Distribution (BB84 Protocol)</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Solving the Weighted Maxcut Problem from Scratch with QAOA</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/Maxcut/maxcut.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Solving the Weighted Maxcut Problem from Scratch with QAOA</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-our-cost-function">Creating our Cost function</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapping-our-cost-function-to-a-hamiltonian">Mapping our Cost Function to a Hamiltonian</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-mixer-hamiltonian">The Mixer Hamiltonian</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#constructing-unitary-operators">Constructing Unitary Operators</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-unitary-operators-into-gates">Turning our Unitary Operators into Gates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unitary-operator-circuit-demo">Unitary Operator Circuit Demo</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#classical-optimization">Classical Optimization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="solving-the-weighted-maxcut-problem-from-scratch-with-qaoa">
<h1>Solving the Weighted Maxcut Problem from Scratch with QAOA<a class="headerlink" href="#solving-the-weighted-maxcut-problem-from-scratch-with-qaoa" title="Link to this heading">#</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>The <a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_cut">MaxCut problem</a> is a well-known optimization problem in which the nodes of a given undirected graph have to be divided in two sets (often referred as the set of “white” and “black” nodes, although in this notebook we’ll use the colours “blue” and “red”) such that the number of edges connecting a white node with a black node are maximized.</p>
<p><img alt="MaxCut Problem Visual" src="../_images/MaxcutWiki.png" /></p>
<p>Here, I’ve implemented the QAOA algorithm to solve the Maxcut problem for weighted graphs, and explained the algorithm along the way. This implementation of QAOA was made from scratch with Qiskit, without using the built in QAOA functionalities of Qiskit Aqua.</p>
<p><em>I originally made this notebook as part of the screening task for the <a class="reference external" href="https://qosf.org">Quantum Open Source Foundation</a>’s mentorship program, which I was fortunate enough to be accepted into! You can find original github repository I submitted <a class="reference external" href="https://github.com/VectorBolt/MaxcutQOSF">here</a>.</em></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># IMPORTS</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
</pre></div>
</div>
</div>
</div>
<p>First, let’s  create a function that can generate a random graphs for us! (The ones that come with the NetworkX package don’t always start counting nodes from 0).</p>
<p>We need to decide how many edges we want. For a connected graph with <span class="math notranslate nohighlight">\(N\)</span> nodes, the minimum number of edges is <span class="math notranslate nohighlight">\(N-1\)</span>. This is easy to see intuitively: It’s just a line connecting each node one by one. The maximum number of edges is <span class="math notranslate nohighlight">\(\frac{N(N-1)}{2}\)</span>. This is because each node can be connected to <span class="math notranslate nohighlight">\(N-1\)</span> other nodes, so we multiply this by the total number of nodes. We divide by two because the graph is undirected.</p>
<p>The graph it generates should be connected, meaning there should always be a path between any two nodes on the graph. To do this, we’ll start by generating the minimum number of edges (the first <span class="math notranslate nohighlight">\(N-1\)</span> edges) by connecting each node in order. To keep it random, we’ll shuffle the order of the nodes first. This would give us a linear graph that looks something like this: <img alt="Unweighted Linear Graph" src="../_images/LinearGraph.png" /></p>
<p>Next, we randomly add more edges. The number of edges we are going to add is <span class="math notranslate nohighlight">\(R - (N-1)\)</span>, where <span class="math notranslate nohighlight">\(R\)</span> is the total number of edges our graph will have. We add each edge by randomly choosing two nodes and checking to make sure the edge connecting them hasn’t already been made.</p>
<p>Finally, we iterate over each edge and randomly give it a weight. Our weight can be a floating point value as well! We’ll round our random weight to the nearest hundredth to make the diagrams look cleaner.</p>
<p>Now we have a working random graph generator! Let’s test it out:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_random_connected_graph</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">max_weight</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a connected graph with a random number of nodes, edges, and weights&quot;&quot;&quot;</span>
    <span class="n">num_edges</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">*</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># Randomly choose the number of edges</span>
    <span class="c1"># Create a list of numbers up to the number of nodes, and shuffle it </span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">))</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># A list of unweighted edges</span>
    <span class="c1"># Create randomly connected graph with the minimum number of edges</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">num_edges</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># Decrement the total number of edges that haven&#39;t been generated yet</span>

    <span class="c1"># Randomly generate extra edges</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_edges</span><span class="p">):</span>
        <span class="c1"># Loop until a valid edge is found</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">start_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">)</span>
            <span class="n">end_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">)</span>
            <span class="c1"># Must be a unique edge between two distinct points</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start_node</span> <span class="o">!=</span> <span class="n">end_node</span> <span class="ow">and</span> <span class="p">[</span><span class="n">start_node</span><span class="p">,</span> <span class="n">end_node</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">):</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start_node</span><span class="p">,</span> <span class="n">end_node</span><span class="p">])</span>
                <span class="k">break</span>

    <span class="c1"># Create graph from edges</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">rand_weight</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_weight</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Weights can be floats. Round to the nearest hundredth </span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">rand_weight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span>

<span class="n">test_graph</span> <span class="o">=</span> <span class="n">generate_random_connected_graph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">test_graph</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(5, 3): Text(0.3686161445614647, -0.5020554723389217, &#39;2.5&#39;),
 (5, 0): Text(-0.33618100421116276, -0.6220000570978355, &#39;5.86&#39;),
 (5, 6): Text(-0.026482372225869816, -0.6687767693460369, &#39;5.89&#39;),
 (3, 4): Text(0.5624615521260552, 0.45225449289740705, &#39;4.32&#39;),
 (3, 2): Text(0.3952012075287499, 0.12488037823718084, &#39;3.73&#39;),
 (3, 6): Text(0.3953127506242439, -0.17083224168495853, &#39;2.97&#39;),
 (4, 1): Text(-0.05912732023604153, 0.665896448206692, &#39;6.41&#39;),
 (4, 2): Text(0.16725149224322663, 0.5812458158124312, &#39;4.65&#39;),
 (1, 2): Text(-0.22638766483334682, 0.33852233354646577, &#39;8.65&#39;),
 (1, 0): Text(-0.5359747537231457, 0.08958642587252787, &#39;9.83&#39;),
 (1, 6): Text(-0.22627612173785278, 0.04280971362432642, &#39;6.68&#39;),
 (2, 0): Text(-0.30959594124387757, 0.004935793478266989, &#39;8.69&#39;),
 (2, 6): Text(0.00010269074141537829, -0.041840918769934454, &#39;6.14&#39;),
 (0, 6): Text(-0.3094843981483835, -0.29077682644387237, &#39;2.99&#39;)}
</pre></div>
</div>
<img alt="../_images/ddb0f3dde4c7204e870698e16184019d3460f913f8e47796afad82d40bd49d10.png" src="../_images/ddb0f3dde4c7204e870698e16184019d3460f913f8e47796afad82d40bd49d10.png" />
</div>
</div>
</section>
<section id="creating-our-cost-function">
<h2>Creating our Cost function<a class="headerlink" href="#creating-our-cost-function" title="Link to this heading">#</a></h2>
<hr class="docutils" />
<p>How do we determine whether the edge between two nodes has been cut? We’ll give each node belonging to one subset a value of 1, and each node belonging to the other subset a value of -1. We want to create a function <span class="math notranslate nohighlight">\(C(s)\)</span> such that <span class="math notranslate nohighlight">\(C(s) = 1\)</span> if the nodes belong to opposite subsets (increasing the “score”) and <span class="math notranslate nohighlight">\(C(s) = 0\)</span> if the nodes belong to opposite subsets (which would not increase the score).</p>
<p>Let’s figure out how to do this. Let <span class="math notranslate nohighlight">\(s_i\)</span> and <span class="math notranslate nohighlight">\(s_j\)</span> represent the values of two nodes (either 1 or -1). Notice that if both nodes belong to the same subset, then <span class="math notranslate nohighlight">\(s_is_j = 1\)</span>, whereas if they belong to opposite subsets, <span class="math notranslate nohighlight">\(s_is_j = -1\)</span>. However, since we want our function to <em>increase</em> the score when <span class="math notranslate nohighlight">\(s_i \neq s_j\)</span>, we’ll multiply by result by <span class="math notranslate nohighlight">\(-1\)</span>.</p>
<p>So far, we have <span class="math notranslate nohighlight">\(C(s) = -s_is_j\)</span>, which gives us <span class="math notranslate nohighlight">\(C(s) = 1\)</span> if <span class="math notranslate nohighlight">\(s_i \neq s_j\)</span>, and <span class="math notranslate nohighlight">\(C(s) = -1\)</span> if <span class="math notranslate nohighlight">\(s_i = s_j\)</span>. To finish constructing our function, we’ll add 1 to <span class="math notranslate nohighlight">\(-s_is_j\)</span> and then divide by 2:
$<span class="math notranslate nohighlight">\(C(s) = \frac{1}{2}(1-s_is_j)\)</span>$</p>
<p>Notice that this gives us exactly what we want: if <span class="math notranslate nohighlight">\(s_i \neq s_j\)</span>, then <span class="math notranslate nohighlight">\(C(s) = 1\)</span>, and if <span class="math notranslate nohighlight">\(s_i = s_j\)</span>, then <span class="math notranslate nohighlight">\(C(s) = 0\)</span>. However, we’re not quite done. This function only gives us the result for one node. To find the total “score” of our solution, we need to sum over all neighboring nodes:
$<span class="math notranslate nohighlight">\(C(s) = \frac{1}{2}\sum_{i,j \in E}{(1-s_is_j)}\)</span><span class="math notranslate nohighlight">\( Where \)</span>E$ is the set of edges. <em>This</em> is the cost function that we are trying to maximize.</p>
<section id="mapping-our-cost-function-to-a-hamiltonian">
<h3>Mapping our Cost Function to a Hamiltonian<a class="headerlink" href="#mapping-our-cost-function-to-a-hamiltonian" title="Link to this heading">#</a></h3>
<p>To solve our problem on a quantum computer, we encode our problem in a Cost Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>. First, let’s reformulate our cost function like this:</p>
<div class="math notranslate nohighlight">
\[C(s) = \frac{1}{2}\sum_{i,j \in E}{(-s_is_j) + const}\]</div>
<p>First, we’ll drop the constants, leaving us with a new objective function <span class="math notranslate nohighlight">\(C'\)</span></p>
<div class="math notranslate nohighlight">
\[C'(s) = \sum_{i,j \in E}{-s_is_j}\]</div>
<p>Our goal is to maximize <span class="math notranslate nohighlight">\(C'(s)\)</span>. To map this to a cost Hamiltonian we’ll replace <span class="math notranslate nohighlight">\(s_i\)</span> and <span class="math notranslate nohighlight">\(s_j\)</span> with Pauli Z operators <span class="math notranslate nohighlight">\(\sigma_i^z\)</span> and <span class="math notranslate nohighlight">\(\sigma_j^z\)</span> acting on qubits <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> respectively. This works because -1 and 1 are the eigenvalues of the Pauli matrices. So far, our cost hamiltonian looks like this:</p>
<div class="math notranslate nohighlight">
\[H_C = \sum_{i,j \in E}{(-\sigma_i^z\sigma_j^z)}\]</div>
<p>There’s just <em>one</em> more thing we need to do: the above hamiltonian only works for an unweighted graph. To generalize it for weighted maxcut problems, we multiply by the weight of the edge, <span class="math notranslate nohighlight">\(w_{ij}\)</span>. Our final cost hamiltonian looks like this:</p>
<div class="math notranslate nohighlight">
\[H_C = \sum_{i,j \in E}{-\sigma_i^z\sigma_j^zw_{ij}}\]</div>
</section>
<section id="the-mixer-hamiltonian">
<h3>The Mixer Hamiltonian<a class="headerlink" href="#the-mixer-hamiltonian" title="Link to this heading">#</a></h3>
<p>In addition to our cost hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>, we’ll also need another Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span> (often called the “Mixer Hamiltonian”) which will be used to escape local minimums. This can be any Hamiltonian that doesn’t commute with <span class="math notranslate nohighlight">\(H_C\)</span>. The one we’re going to use is a simple Pauli X operator:</p>
<div class="math notranslate nohighlight">
\[H_B = \sum_{i \in V}\sigma_i^x\]</div>
</section>
</section>
<section id="constructing-unitary-operators">
<h2>Constructing Unitary Operators<a class="headerlink" href="#constructing-unitary-operators" title="Link to this heading">#</a></h2>
<hr class="docutils" />
<p>Alright, we have our hamiltonians, but what do we do with them? What we do in QAOA is implement paramterized unitary operators corresponding to our hamiltonians. With our Cost Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>. we create an operator <span class="math notranslate nohighlight">\(U(H_C, \gamma) = e^{-i \gamma H_C}\)</span>, and with our Mixer Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span>, we create an operator <span class="math notranslate nohighlight">\(U(H_B, \beta) = e^{-i \beta H_B}\)</span>.</p>
<p>Whoa, hold on, what does all this exponentiated hamiltonian stuff mean? The section “Background: Quantum Mechanics” in <a class="reference external" href="https://www.mustythoughts.com/quantum-approximate-optimization-algorithm-explained">this article</a> does a great job explaining it. Basically, we can think of <span class="math notranslate nohighlight">\(e^{-itH}\)</span> as the evolution of the state of the quantum system for time <span class="math notranslate nohighlight">\(t\)</span>, as described by the hamiltonian <span class="math notranslate nohighlight">\(H\)</span>. Our unitaries <span class="math notranslate nohighlight">\(e^{-i \gamma H_C}\)</span> and <span class="math notranslate nohighlight">\(e^{-i \beta H_B}\)</span> do something like this for the hamiltonians <span class="math notranslate nohighlight">\(H_C\)</span> and <span class="math notranslate nohighlight">\(H_C\)</span>. We’ve constructed our hamiltonians in such a way that each of our hamiltonian can be thought of as a matrix that rotates the qubits of our system around a particular axis of the bloch sphere. Instead of evolving the state for a time <span class="math notranslate nohighlight">\(t\)</span>, we’re evolving the state by rotating the qubits by an angle proportional to our parameters <span class="math notranslate nohighlight">\(\gamma\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span>. To solve the maxcut problem, all we need to do is find the optimal parameters.</p>
<p>So how do we use these unitary operators? Well, let’s breifly recall what QAOA does.</p>
<p>We start with <span class="math notranslate nohighlight">\(n\)</span> qubits (where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in our graph) and we apply a Hadamard gate on each one, creating an equal superposition state <span class="math notranslate nohighlight">\(|+...+\rangle\)</span>. We’ll call this state <span class="math notranslate nohighlight">\(|s\rangle\)</span>. Then we repeatedly apply our parametrized cost and mixer unitaries to construct the following state:</p>
<div class="math notranslate nohighlight">
\[U(H_B, \beta_p)U(H_C, \gamma_p)...U(H_B, \beta_1)U(H_C, \gamma_1)|s\rangle\]</div>
<p>Overall, the QAOA circuit looks like this:</p>
<p><img alt="QAOA Circuit Diagram" src="../_images/qaoa_circuit.png" /></p>
<p>The repetition of applying our cost and mixer unitaries in an alternating fashion is called Trotterization. It a is a way of approximating the adiabatic pathway.</p>
<section id="turning-our-unitary-operators-into-gates">
<h3>Turning our Unitary Operators into Gates<a class="headerlink" href="#turning-our-unitary-operators-into-gates" title="Link to this heading">#</a></h3>
<p>To actually create our quantum circuit, we need to be able to express our unitary operators as a series of gates. How do we do that?</p>
<p>First, let’s figure out how to translate are cost unitary to quantum gates. Remember that our cost unitary is <span class="math notranslate nohighlight">\(e^{-i\gamma H_C} = e^{-i\gamma (-\sigma_i^z\sigma_j^zw_{ij})}\)</span></p>
<p>One gate that will be useful is the <span class="math notranslate nohighlight">\(R_z\)</span> gate, which rotates the state around the <span class="math notranslate nohighlight">\(z\)</span> axis of the bloch sphere by an angle <span class="math notranslate nohighlight">\(\frac{\theta}{2}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}R_z(\theta) = e^{-i\frac{\theta}{2}\sigma_z} = 
\cos{\frac{\theta}{2}}I - i\sin{\frac{\theta}{2}}\sigma_z =
\begin{bmatrix} 
e^{-i\frac{\theta}{2}} &amp; 0 \\
0 &amp; e^{i\frac{\theta}{2}}
\end{bmatrix}\end{split}\]</div>
<p>Of course, this is only a one-qubit gate. How do we implement the two-qubit unitary <span class="math notranslate nohighlight">\(e^{-i\frac{\theta}{2}\sigma_i^z\sigma_j^z}\)</span>? One way to see what the effect of this unitary is to observe the effect of applying it to all computational basis states, and replacing the Pauli Z operators with their eigenvalues corresponding to the computational basis states. This slide from Ruslan Shaydulin <a class="reference external" href="https://www.youtube.com/watch?v=AOKM9BkweVU&amp;amp;list=WL&amp;amp;index=21&amp;amp;t=948s">tutorial</a> explains it well: <img alt="Effect of unitary on all computational basis states" src="../_images/gate_mapping.png" /></p>
<p>We can use the CNOT gate to check the parity of qubit <span class="math notranslate nohighlight">\(i\)</span> and qubit <span class="math notranslate nohighlight">\(j\)</span>, then apply our <span class="math notranslate nohighlight">\(R_z\)</span> gate, and then add another CNOT to undo the effect of the first CNOT. The resulting circuit looks like this: <img alt="Cost Unitary Circuit" src="../_images/gate_mapping2.png" />
In this case, <span class="math notranslate nohighlight">\(t\)</span> represents the parameter we pass in (either <span class="math notranslate nohighlight">\(\gamma\)</span> or <span class="math notranslate nohighlight">\(\beta\)</span>). The reason we multiply by two is because the <span class="math notranslate nohighlight">\(R_z(\theta)\)</span> gate rotates by <span class="math notranslate nohighlight">\(\frac{\theta}{2}\)</span>, so multiplying by 2 allows us to rotate by <span class="math notranslate nohighlight">\(\gamma\)</span> or <span class="math notranslate nohighlight">\(\beta\)</span>. Also, since we are solving for weighted graphs, we multiply <span class="math notranslate nohighlight">\(\gamma\)</span> by the weight of the edge. Thus, we end up with an <span class="math notranslate nohighlight">\(R_z(2\gamma w_{ij})\)</span> gate sandwiched between two CNOTs.</p>
<p>Finally, we need to translate our mixer unitary into gates. This one is easy: just as single-qubit <span class="math notranslate nohighlight">\(R_x(2\beta)\)</span> gate. (We’re multiplying by 2 for the same reason we did this for our cost unitary).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Hamiltonians</span>
<span class="k">def</span> <span class="nf">create_cost_unitary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implement the cost unitary on a quantum circuit&quot;&quot;&quot;</span>
    
    <span class="n">cost_unitary</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cost Unitary&quot;</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="c1"># Get weights from graph</span>
    
    <span class="c1"># Add corresponding gates for each edge</span>
    <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">cost_unitary</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">cost_unitary</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="n">weight</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">cost_unitary</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">cost_unitary</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span> <span class="c1"># Visually the unitary for each edge</span>
    <span class="c1">#cost_unitary.to_gate()</span>
    <span class="k">return</span> <span class="n">cost_unitary</span>

<span class="k">def</span> <span class="nf">create_mixer_unitary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implement the mixer unitary on a quantum circuit&quot;&quot;&quot;</span>
    <span class="n">mixer_unitary</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Mixer Unitary&quot;</span><span class="p">)</span>
    
    <span class="c1"># Apply unitary for each node</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span> 
        <span class="n">mixer_unitary</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">mixer_unitary</span><span class="o">.</span><span class="n">to_gate</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mixer_unitary</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="unitary-operator-circuit-demo">
<h3>Unitary Operator Circuit Demo<a class="headerlink" href="#unitary-operator-circuit-demo" title="Link to this heading">#</a></h3>
<p>This is what it would look like if we applied the cost unitary for every edge on our test graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A demonstration of what the cost unitary circuit might look like</span>
<span class="n">test_cost_unitary</span> <span class="o">=</span> <span class="n">create_cost_unitary</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># pi/3 is an arbitrarily chosen angle for demonstration</span>
<span class="n">test_cost_unitary</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bd9b3ce7bd5c22c5c6eb343a78c41e4f5de766be12485277ce6b2fd0f639bb40.png" src="../_images/bd9b3ce7bd5c22c5c6eb343a78c41e4f5de766be12485277ce6b2fd0f639bb40.png" />
</div>
</div>
<p>And this is what the applying the mixer unitary would look like for each node.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A demonstration of what the mixer unitary circuit might look like</span>
<span class="n">test_mixer_unitary</span> <span class="o">=</span> <span class="n">create_mixer_unitary</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="n">test_mixer_unitary</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/070b357901e378ee57598ea19118c3f3e5c24c376b57b09577dd4cfae306e198.png" src="../_images/070b357901e378ee57598ea19118c3f3e5c24c376b57b09577dd4cfae306e198.png" />
</div>
</div>
<p>Finally, we can create our QAOA circuit. The number of qubits and is the same as the number of nodes in our graph. We start by applying a layer of Hadamard gates to produce our initial superposition state <span class="math notranslate nohighlight">\(|s\rangle\)</span>. Then, we alternate applying our cost and mixer unitaries. Each time we apply a layer of cost and mixer unitaries corresponds to one iteration.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_qaoa_circuit</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the full QAOA circuit for the graph with the given parameters.&quot;&quot;&quot;</span>
    <span class="n">num_of_iterations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">gammas</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="n">num_of_iterations</span><span class="p">]</span> <span class="c1"># Let the first half of the params list be gamma parameters</span>
    <span class="n">betas</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">num_of_iterations</span><span class="p">:]</span> <span class="c1"># Let the second half of the params list be beta parameters</span>

    <span class="c1"># Initialize Circuit</span>
    <span class="n">qr</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
    <span class="n">cr</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qr</span><span class="p">,</span> <span class="n">cr</span><span class="p">)</span>

    <span class="c1"># Put all qubits in superposition with hadamard gates</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_of_iterations</span><span class="p">):</span>
        <span class="c1"># Get Cost and Mixer Unitaries</span>
        <span class="n">cost_unitary</span> <span class="o">=</span> <span class="n">create_cost_unitary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">gammas</span><span class="p">[</span><span class="n">iteration</span><span class="p">])</span>
        <span class="n">mixer_unitary</span> <span class="o">=</span> <span class="n">create_mixer_unitary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">betas</span><span class="p">[</span><span class="n">iteration</span><span class="p">])</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_unitary</span><span class="p">,</span> <span class="n">qr</span><span class="p">)</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mixer_unitary</span><span class="p">,</span> <span class="n">qr</span><span class="p">)</span>

    <span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qr</span><span class="p">,</span> <span class="n">cr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circuit</span>
  
</pre></div>
</div>
</div>
</div>
<p>Next, we want to find the expectation <span class="math notranslate nohighlight">\(\langle\psi|C|\psi\rangle\)</span> of our QAOA circuit with the state corresponding to the parameters passed in. We can approximate this by taking the results of our quantum circuit and calculating the weighted average of the value of the cut for each bitstring.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_cut_size</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">bit_string</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the value of the cut associated with a given bitstring,</span>
<span class="sd">    meaning the weighted sum of all of the edges connecting two nodes belonging to opposite subsets.</span>
<span class="sd">    Since the classical optimizer is designed to compute a minimum instead of a maximum,</span>
<span class="sd">    we multiply our cut size by negative one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cut_size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="c1"># Get list of weights for each edge</span>
    
    <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">start_node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">end_node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">bit_string</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bit_string</span><span class="p">[</span><span class="n">end_node</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Since the classical optimizer is designed to compute a minimum instead of a maximum,</span>
<span class="sd">            decrement the cut size instead of incrementing it.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">cut_size</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">*</span><span class="n">weight</span>
    <span class="k">return</span> <span class="n">cut_size</span>

<span class="k">def</span> <span class="nf">get_expectation</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the weighted average of the results of the quantum circuit.&quot;&quot;&quot;</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="n">total_executions</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">bit_string</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="n">frequency</span> <span class="o">*</span> <span class="n">get_cut_size</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">bit_string</span><span class="p">)</span>
        <span class="n">total_executions</span> <span class="o">+=</span> <span class="n">frequency</span>
    <span class="k">return</span> <span class="n">energy</span> <span class="o">/</span> <span class="n">total_executions</span> <span class="c1"># Return the average</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we’ll create an array of graphs that we can test our solution on! For the sake of this project, I’ll only run the algorithm on the first graph, but implementing support for an array allows for scalability.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Modifiable constants determining the properties of our list of graphs</span>
<span class="n">NUM_OF_GRAPHS</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">MAX_NUMBER_OF_NODES</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">MAX_WEIGHT</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Create list of graphs to perform QAOA on</span>
<span class="n">graphs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_OF_GRAPHS</span><span class="p">):</span>
    <span class="n">graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_random_connected_graph</span><span class="p">(</span><span class="n">MAX_NUMBER_OF_NODES</span><span class="p">,</span> <span class="n">MAX_WEIGHT</span><span class="p">))</span>

<span class="c1"># Draw Graphs</span>
<span class="k">for</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span> <span class="c1"># Display each graph separately</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/2cd9948d286b33a2110e2251def0fa64cd8bf14c7ea068e7e3aab85e0c559426.png" src="../_images/2cd9948d286b33a2110e2251def0fa64cd8bf14c7ea068e7e3aab85e0c559426.png" />
<img alt="../_images/b8592fb760b48bbf54086a9a1f2edfa9ac419bdd8fa8f054a8161c640dbab2fc.png" src="../_images/b8592fb760b48bbf54086a9a1f2edfa9ac419bdd8fa8f054a8161c640dbab2fc.png" />
<img alt="../_images/1678b44cd614ea7919fe245379a3c0820533931de31eec481b45818a3326a9f7.png" src="../_images/1678b44cd614ea7919fe245379a3c0820533931de31eec481b45818a3326a9f7.png" />
<img alt="../_images/5201a62b5efe184ae0a73d23567096dc09be146b9305648fd6de335f41570039.png" src="../_images/5201a62b5efe184ae0a73d23567096dc09be146b9305648fd6de335f41570039.png" />
<img alt="../_images/7a0cec773ecf415b9d08990200bd46d76241b02a5814841047b7ae0f5d5d4d0c.png" src="../_images/7a0cec773ecf415b9d08990200bd46d76241b02a5814841047b7ae0f5d5d4d0c.png" />
</div>
</div>
</section>
</section>
<section id="classical-optimization">
<h2>Classical Optimization<a class="headerlink" href="#classical-optimization" title="Link to this heading">#</a></h2>
<hr class="docutils" />
<p>We define an objective function that the SciPy optimizer can find the optimal parameters for. The function returns the expectation of the QAOA circuit. The goal of the optimizer we choose will be to minimize this expectation value.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">CURRENT_GRAPH</span> <span class="o">=</span> <span class="n">graphs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s2">&quot;qasm_simulator&quot;</span><span class="p">)</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">create_qaoa_circuit</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="c1"># Invert bitstrings because Qiskit uses different order</span>
    <span class="k">return</span> <span class="n">get_expectation</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here, we define our initial list of parameters that SciPy will optimize. The length of this list determines the depth of our circuit (how many iterations we want to apply our unitary layers for). We’ll initialize a random set of parameters between 0 and <span class="math notranslate nohighlight">\(\pi\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">NUM_OF_ITERATIONS</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">init_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">NUM_OF_ITERATIONS</span><span class="p">)]</span>

<span class="n">solution</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">init_params</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;COBYLA&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>     fun: -14.68439453125
   maxcv: 0.0
 message: &#39;Optimization terminated successfully.&#39;
    nfev: 70
  status: 1
 success: True
       x: array([4.06844933, 0.15690518, 1.42738659, 0.87646885, 0.29846743,
       3.42030986])
</pre></div>
</div>
</div>
</div>
<p>Now that we’ve found the optimal parameters, let’s plug them into our QAOA circuit and see the results! The spikes on the graph correspond to the best solutions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s2">&quot;qasm_simulator&quot;</span><span class="p">)</span>
<span class="n">optimized_params</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="n">optimal_circuit</span> <span class="o">=</span> <span class="n">create_qaoa_circuit</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">optimized_params</span><span class="p">)</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">optimal_circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="c1"># Invert bitstrings because Qiskit uses different order</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/29b212d468c46e983e34f446c3be8d538ed26c9ed165ec2dbb28c8c9160d639c.png" src="../_images/29b212d468c46e983e34f446c3be8d538ed26c9ed165ec2dbb28c8c9160d639c.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Print Counts</span>
<span class="k">for</span> <span class="n">bit_string</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">bit_string</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">frequency</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>000000: 1
100000: 6
000010: 15
100010: 24
010010: 20
110010: 77
001010: 2
101010: 4
011010: 9
111010: 5
000110: 6
100110: 5
010110: 5
110110: 8
101110: 3
011110: 18
111110: 1
010000: 5
000001: 2
100001: 23
010001: 5
001001: 16
101001: 13
011001: 5
111001: 8
000101: 8
100101: 9
010101: 4
001101: 96
101101: 12
011101: 31
111101: 18
110000: 40
000011: 20
100011: 123
010011: 3
110011: 45
001011: 4
101011: 10
011011: 11
111011: 4
000111: 4
010111: 1
110111: 4
001111: 33
101111: 6
011111: 6
001000: 3
011000: 1
111000: 8
000100: 8
100100: 8
010100: 8
110100: 4
001100: 39
101100: 8
011100: 131
111100: 28
</pre></div>
</div>
</div>
</div>
<p>There may be more than one solution. We’ll select the bitstring with the highest frequency as our solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Print the bitstring with the highest frequency</span>
<span class="n">solution_string</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
<span class="n">solution_cut_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">get_cut_size</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">solution_string</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Our solution is &quot;</span> <span class="o">+</span> <span class="n">solution_string</span> <span class="o">+</span> <span class="s2">&quot; with a cut value of &quot;</span> 
      <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">solution_cut_value</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Our solution is 011100 with a cut value of 18.61
</pre></div>
</div>
</div>
</div>
<p>Now let’s visualize our result by coloring the graph!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">color_graph</span><span class="p">(</span><span class="n">bit_string</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function determines how to color a graph for a given bitstring.&quot;&quot;&quot;</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bit_string</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bit</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">colors</span>

<span class="c1"># Show the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">color_graph</span><span class="p">(</span><span class="n">solution_string</span><span class="p">))</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(1, 3): Text(-0.01674753771946949, 0.28545177409616207, &#39;1.75&#39;),
 (1, 5): Text(0.715466761029708, 0.474791601952659, &#39;2.78&#39;),
 (1, 4): Text(0.3195570920586174, -0.13284077817626752, &#39;2.08&#39;),
 (3, 0): Text(-0.5959727064172196, 0.11181633399969876, &#39;7.07&#39;),
 (0, 2): Text(-0.5873427933094396, -0.367133063241776, &#39;3.65&#39;),
 (0, 5): Text(0.13624159233195787, 0.30115616185619576, &#39;0.03&#39;),
 (2, 4): Text(-0.11949405461248812, -0.5866079359523575, &#39;3.03&#39;)}
</pre></div>
</div>
<img alt="../_images/4a94fe6e2c0642ef750b5226dde6e3a70bd663db8a1ee87da7d18b1d698c1a01.png" src="../_images/4a94fe6e2c0642ef750b5226dde6e3a70bd663db8a1ee87da7d18b1d698c1a01.png" />
</div>
</div>
<p>How does this compare to the actual solution? To check, we’ll use a brute force approach to find the solution classically.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compare QAOA Solution to actual solution</span>
<span class="n">all_possibilities</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">bit_string</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">all_possibilities</span><span class="p">[</span><span class="n">bit_string</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_cut_size</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">bit_string</span><span class="p">)</span>

<span class="n">actual_solution</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">all_possibilities</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">all_possibilities</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
<span class="n">actual_solution_cut_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">get_cut_size</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">actual_solution</span><span class="p">)</span> <span class="c1"># Multiply by one to get a positive result</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The actual solution is </span><span class="si">{</span><span class="n">actual_solution</span><span class="si">}</span><span class="s2"> with a cut value of </span><span class="si">{</span><span class="n">actual_solution_cut_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The actual solution is 100011 with a cut value of 18.61
</pre></div>
</div>
</div>
</div>
<p>And finally, let’s visualize the actual solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">color_graph</span><span class="p">(</span><span class="n">actual_solution</span><span class="p">))</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(1, 3): Text(0.01604946461088566, 0.2847479650782671, &#39;1.75&#39;),
 (1, 5): Text(-0.7146239765611268, 0.4636686593078169, &#39;2.78&#39;),
 (1, 4): Text(-0.31626451499441, -0.12780905025779288, &#39;2.08&#39;),
 (3, 0): Text(0.5948398177769747, 0.11336473757454996, &#39;7.07&#39;),
 (0, 2): Text(0.5855910738223974, -0.3598274981764227, &#39;3.65&#39;),
 (0, 5): Text(-0.13583362339503774, 0.29228543180409977, &#39;0.03&#39;),
 (2, 4): Text(0.11978415878415191, -0.5770333968823671, &#39;3.03&#39;)}
</pre></div>
</div>
<img alt="../_images/21e0fbf4733c033a29c6b33a665cc6658b411da2bab5a97190085ead568fdca5.png" src="../_images/21e0fbf4733c033a29c6b33a665cc6658b411da2bab5a97190085ead568fdca5.png" />
</div>
</div>
<p>So how does our QAOA circuit stack up against brute force, in terms of finding the correct answer? Well, we can use the ratio between the cut value from the QAOA’s answer and the cut value of the correct answer. A higher number means that our QAOA did a better job. For small graphs, we can even get the exact correct answer, resulting in a ratio of 1.0!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">solution_cut_value</span> <span class="o">/</span> <span class="n">actual_solution_cut_value</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0
</pre></div>
</div>
</div>
</div>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Musty Thoughts. <a class="reference external" href="https://www.mustythoughts.com/quantum-approximate-optimization-algorithm-explained">https://www.mustythoughts.com/quantum-approximate-optimization-algorithm-explained</a></p></li>
<li><p>Musty Thoughts. <a class="reference external" href="https://www.mustythoughts.com/vqas-how-do-they-work">https://www.mustythoughts.com/vqas-how-do-they-work</a></p></li>
<li><p>Jack Ceroni’s code: <a class="reference external" href="https://lucaman99.github.io/new_blog/2020/mar16.html">https://lucaman99.github.io/new_blog/2020/mar16.html</a></p></li>
<li><p>Ruslan Shaydulin’s Tutorial [Part 1]: <a class="reference external" href="https://youtu.be/AOKM9BkweVU">https://youtu.be/AOKM9BkweVU</a></p></li>
<li><p>Ruslan Shaydulin’s Tutorial [Part 2]: <a class="reference external" href="https://youtu.be/E0Sos_lR-kI">https://youtu.be/E0Sos_lR-kI</a></p></li>
<li><p>Ruslan Shaydulin’s Notebook: <a class="github reference external" href="https://github.com/rsln-s/IEEE_QW_2020">rsln-s/IEEE_QW_2020</a></p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Maxcut"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../Quantum%20Key%20Distribution.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Quantum Key Distribution (BB84 Protocol)</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-our-cost-function">Creating our Cost function</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapping-our-cost-function-to-a-hamiltonian">Mapping our Cost Function to a Hamiltonian</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-mixer-hamiltonian">The Mixer Hamiltonian</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#constructing-unitary-operators">Constructing Unitary Operators</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-unitary-operators-into-gates">Turning our Unitary Operators into Gates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unitary-operator-circuit-demo">Unitary Operator Circuit Demo</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#classical-optimization">Classical Optimization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Avneesh Verma
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maxcut &#8212; Avneesh Verma</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/sphinx-book-theme.37f24b989f4638ff9c27c22dc7559d4f.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/my-style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Encoding the quantum state to be teleported." href="../teleportation.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/Headshot.jpeg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Avneesh Verma</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../landing-page.html">
   Avneesh Verma
  </a>
 </li>
</ul>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../teleportation.html">
   Encoding the quantum state to be teleported.
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Maxcut
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/Maxcut/maxcut.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                    title="Fullscreen mode"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/Maxcut/maxcut.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#creating-our-cost-function">
   Creating our Cost function
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mapping-our-cost-function-to-a-hamiltonian">
     Mapping our Cost Function to a Hamiltonian
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-mixer-hamiltonian">
     The Mixer Hamiltonian
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#constructing-unitary-operators">
   Constructing Unitary Operators
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#turning-our-unitary-operators-into-gates">
     Turning our Unitary Operators into Gates
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unitary-operator-circuit-demo">
     Unitary Operator Circuit Demo
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#classical-optimization">
   Classical Optimization
  </a>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="maxcut">
<h1>Maxcut<a class="headerlink" href="#maxcut" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># IMPORTS</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
</pre></div>
</div>
</div>
</div>
<p>First, let’s  create a function that can generate a random graphs for us! (The ones that come with the NetworkX package don’t always start counting nodes from 0).</p>
<p>We need to decide how many edges we want. For a connected graph with <span class="math notranslate nohighlight">\(N\)</span> nodes, the minimum number of edges is <span class="math notranslate nohighlight">\(N-1\)</span>. This is easy to see intuitively: It’s just a line connecting each node one by one. The maximum number of edges is <span class="math notranslate nohighlight">\(\frac{N(N-1)}{2}\)</span>. This is because each node can be connected to <span class="math notranslate nohighlight">\(N-1\)</span> other nodes, so we multiply this by the total number of nodes. We divide by two because the graph is undirected.</p>
<p>The graph it generates should be connected, meaning there should always be a path between any two nodes on the graph. To do this, we’ll start by generating the minimum number of edges (the first <span class="math notranslate nohighlight">\(N-1\)</span> edges) by connecting each node in order. To keep it random, we’ll shuffle the order of the nodes first. This would give us a linear graph that looks something like this: <img alt="Unweighted Linear Graph" src="../_images/LinearGraph.png" /></p>
<p>Next, we randomly add more edges. The number of edges we are going to add is <span class="math notranslate nohighlight">\(R - (N-1)\)</span>, where <span class="math notranslate nohighlight">\(R\)</span> is the total number of edges our graph will have. We add each edge by randomly choosing two nodes and checking to make sure the edge connecting them hasn’t already been made.</p>
<p>Finally, we iterate over each edge and randomly give it a weight. Our weight can be a floating point value as well! We’ll round our random weight to the nearest hundredth to make the diagrams look cleaner.</p>
<p>Now we have a working random graph generator! Let’s test it out:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_random_connected_graph</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">max_weight</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a connected graph with a random number of nodes, edges, and weights&quot;&quot;&quot;</span>
    <span class="n">num_edges</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">*</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># Randomly choose the number of edges</span>
    <span class="c1"># Create a list of numbers up to the number of nodes, and shuffle it </span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">))</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># A list of unweighted edges</span>
    <span class="c1"># Create randomly connected graph with the minimum number of edges</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">num_edges</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># Decrement the total number of edges that haven&#39;t been generated yet</span>

    <span class="c1"># Randomly generate extra edges</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_edges</span><span class="p">):</span>
        <span class="c1"># Loop until a valid edge is found</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">start_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">)</span>
            <span class="n">end_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">)</span>
            <span class="c1"># Must be a unique edge between two distinct points</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start_node</span> <span class="o">!=</span> <span class="n">end_node</span> <span class="ow">and</span> <span class="p">[</span><span class="n">start_node</span><span class="p">,</span> <span class="n">end_node</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">):</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start_node</span><span class="p">,</span> <span class="n">end_node</span><span class="p">])</span>
                <span class="k">break</span>

    <span class="c1"># Create graph from edges</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">rand_weight</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_weight</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Weights can be floats. Round to the nearest hundredth </span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">rand_weight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span>

<span class="n">test_graph</span> <span class="o">=</span> <span class="n">generate_random_connected_graph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">test_graph</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(5, 3): Text(0.3686161445614647, -0.5020554723389217, &#39;2.5&#39;),
 (5, 0): Text(-0.33618100421116276, -0.6220000570978355, &#39;5.86&#39;),
 (5, 6): Text(-0.026482372225869816, -0.6687767693460369, &#39;5.89&#39;),
 (3, 4): Text(0.5624615521260552, 0.45225449289740705, &#39;4.32&#39;),
 (3, 2): Text(0.3952012075287499, 0.12488037823718084, &#39;3.73&#39;),
 (3, 6): Text(0.3953127506242439, -0.17083224168495853, &#39;2.97&#39;),
 (4, 1): Text(-0.05912732023604153, 0.665896448206692, &#39;6.41&#39;),
 (4, 2): Text(0.16725149224322663, 0.5812458158124312, &#39;4.65&#39;),
 (1, 2): Text(-0.22638766483334682, 0.33852233354646577, &#39;8.65&#39;),
 (1, 0): Text(-0.5359747537231457, 0.08958642587252787, &#39;9.83&#39;),
 (1, 6): Text(-0.22627612173785278, 0.04280971362432642, &#39;6.68&#39;),
 (2, 0): Text(-0.30959594124387757, 0.004935793478266989, &#39;8.69&#39;),
 (2, 6): Text(0.00010269074141537829, -0.041840918769934454, &#39;6.14&#39;),
 (0, 6): Text(-0.3094843981483835, -0.29077682644387237, &#39;2.99&#39;)}
</pre></div>
</div>
<img alt="../_images/maxcut_3_1.png" src="../_images/maxcut_3_1.png" />
</div>
</div>
<div class="section" id="creating-our-cost-function">
<h2>Creating our Cost function<a class="headerlink" href="#creating-our-cost-function" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<p>How do we determine whether the edge between two nodes has been cut? We’ll give each node belonging to one subset a value of 1, and each node belonging to the other subset a value of -1. We want to create a function <span class="math notranslate nohighlight">\(C(s)\)</span> such that <span class="math notranslate nohighlight">\(C(s) = 1\)</span> if the nodes belong to opposite subsets (increasing the “score”) and <span class="math notranslate nohighlight">\(C(s) = 0\)</span> if the nodes belong to opposite subsets (which would not increase the score).</p>
<p>Let’s figure out how to do this. Let <span class="math notranslate nohighlight">\(s_i\)</span> and <span class="math notranslate nohighlight">\(s_j\)</span> represent the values of two nodes (either 1 or -1). Notice that if both nodes belong to the same subset, then <span class="math notranslate nohighlight">\(s_is_j = 1\)</span>, whereas if they belong to opposite subsets, <span class="math notranslate nohighlight">\(s_is_j = -1\)</span>. However, since we want our function to <em>increase</em> the score when <span class="math notranslate nohighlight">\(s_i \neq s_j\)</span>, we’ll multiply by result by <span class="math notranslate nohighlight">\(-1\)</span>.</p>
<p>So far, we have <span class="math notranslate nohighlight">\(C(s) = -s_is_j\)</span>, which gives us <span class="math notranslate nohighlight">\(C(s) = 1\)</span> if <span class="math notranslate nohighlight">\(s_i \neq s_j\)</span>, and <span class="math notranslate nohighlight">\(C(s) = -1\)</span> if <span class="math notranslate nohighlight">\(s_i = s_j\)</span>. To finish constructing our function, we’ll add 1 to <span class="math notranslate nohighlight">\(-s_is_j\)</span> and then divide by 2:
$<span class="math notranslate nohighlight">\(C(s) = \frac{1}{2}(1-s_is_j)\)</span>$</p>
<p>Notice that this gives us exactly what we want: if <span class="math notranslate nohighlight">\(s_i \neq s_j\)</span>, then <span class="math notranslate nohighlight">\(C(s) = 1\)</span>, and if <span class="math notranslate nohighlight">\(s_i = s_j\)</span>, then <span class="math notranslate nohighlight">\(C(s) = 0\)</span>. However, we’re not quite done. This function only gives us the result for one node. To find the total “score” of our solution, we need to sum over all neighboring nodes:
$<span class="math notranslate nohighlight">\(C(s) = \frac{1}{2}\sum_{i,j \in E}{(1-s_is_j)}\)</span><span class="math notranslate nohighlight">\( Where \)</span>E$ is the set of edges. <em>This</em> is the cost function that we are trying to maximize.</p>
<div class="section" id="mapping-our-cost-function-to-a-hamiltonian">
<h3>Mapping our Cost Function to a Hamiltonian<a class="headerlink" href="#mapping-our-cost-function-to-a-hamiltonian" title="Permalink to this headline">¶</a></h3>
<p>To solve our problem on a quantum computer, we encode our problem in a Cost Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>. First, let’s reformulate our cost function like this:</p>
<div class="math notranslate nohighlight">
\[C(s) = \frac{1}{2}\sum_{i,j \in E}{(-s_is_j) + const}\]</div>
<p>First, we’ll drop the constants, leaving us with a new objective function <span class="math notranslate nohighlight">\(C'\)</span></p>
<div class="math notranslate nohighlight">
\[C'(s) = \sum_{i,j \in E}{-s_is_j}\]</div>
<p>Our goal is to maximize <span class="math notranslate nohighlight">\(C'(s)\)</span>. To map this to a cost Hamiltonian we’ll replace <span class="math notranslate nohighlight">\(s_i\)</span> and <span class="math notranslate nohighlight">\(s_j\)</span> with Pauli Z operators <span class="math notranslate nohighlight">\(\sigma_i^z\)</span> and <span class="math notranslate nohighlight">\(\sigma_j^z\)</span> acting on qubits <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> respectively. This works because -1 and 1 are the eigenvalues of the Pauli matrices. So far, our cost hamiltonian looks like this:</p>
<div class="math notranslate nohighlight">
\[H_C = \sum_{i,j \in E}{(-\sigma_i^z\sigma_j^z)}\]</div>
<p>There’s just <em>one</em> more thing we need to do: the above hamiltonian only works for an unweighted graph. To generalize it for weighted maxcut problems, we multiply by the weight of the edge, <span class="math notranslate nohighlight">\(w_{ij}\)</span>. Our final cost hamiltonian looks like this:</p>
<div class="math notranslate nohighlight">
\[H_C = \sum_{i,j \in E}{-\sigma_i^z\sigma_j^zw_{ij}}\]</div>
</div>
<div class="section" id="the-mixer-hamiltonian">
<h3>The Mixer Hamiltonian<a class="headerlink" href="#the-mixer-hamiltonian" title="Permalink to this headline">¶</a></h3>
<p>In addition to our cost hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>, we’ll also need another Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span> (often called the “Mixer Hamiltonian”) which will be used to escape local minimums. This can be any Hamiltonian that doesn’t commute with <span class="math notranslate nohighlight">\(H_C\)</span>. The one we’re going to use is a simple Pauli X operator:</p>
<div class="math notranslate nohighlight">
\[H_B = \sum_{i \in V}\sigma_i^x\]</div>
</div>
</div>
<div class="section" id="constructing-unitary-operators">
<h2>Constructing Unitary Operators<a class="headerlink" href="#constructing-unitary-operators" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<p>Alright, we have our hamiltonians, but what do we do with them? What we do in QAOA is implement paramterized unitary operators corresponding to our hamiltonians. With our Cost Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>. we create an operator <span class="math notranslate nohighlight">\(U(H_C, \gamma) = e^{-i \gamma H_C}\)</span>, and with our Mixer Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span>, we create an operator <span class="math notranslate nohighlight">\(U(H_B, \beta) = e^{-i \beta H_B}\)</span>.</p>
<p>Whoa, hold on, what does all this exponentiated hamiltonian stuff mean? The section “Background: Quantum Mechanics” in <a class="reference external" href="https://www.mustythoughts.com/quantum-approximate-optimization-algorithm-explained">this article</a> does a great job explaining it. Basically, we can think of <span class="math notranslate nohighlight">\(e^{-itH}\)</span> as the evolution of the state of the quantum system for time <span class="math notranslate nohighlight">\(t\)</span>, as described by the hamiltonian <span class="math notranslate nohighlight">\(H\)</span>. Our unitaries <span class="math notranslate nohighlight">\(e^{-i \gamma H_C}\)</span> and <span class="math notranslate nohighlight">\(e^{-i \beta H_B}\)</span> do something like this for the hamiltonians <span class="math notranslate nohighlight">\(H_C\)</span> and <span class="math notranslate nohighlight">\(H_C\)</span>. We’ve constructed our hamiltonians in such a way that each of our hamiltonian can be thought of as a matrix that rotates the qubits of our system around a particular axis of the bloch sphere. Instead of evolving the state for a time <span class="math notranslate nohighlight">\(t\)</span>, we’re evolving the state by rotating the qubits by an angle proportional to our parameters <span class="math notranslate nohighlight">\(\gamma\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span>. To solve the maxcut problem, all we need to do is find the optimal parameters.</p>
<p>So how do we use these unitary operators? Well, let’s breifly recall what QAOA does.</p>
<p>We start with <span class="math notranslate nohighlight">\(n\)</span> qubits (where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in our graph) and we apply a Hadamard gate on each one, creating an equal superposition state <span class="math notranslate nohighlight">\(|+...+\rangle\)</span>. We’ll call this state <span class="math notranslate nohighlight">\(|s\rangle\)</span>. Then we repeatedly apply our parametrized cost and mixer unitaries to construct the following state:</p>
<div class="math notranslate nohighlight">
\[U(H_B, \beta_p)U(H_C, \gamma_p)...U(H_B, \beta_1)U(H_C, \gamma_1)|s\rangle\]</div>
<p>Overall, the QAOA circuit looks like this:</p>
<p><img alt="QAOA Circuit Diagram" src="../_images/qaoa_circuit.png" /></p>
<p>The repetition of applying our cost and mixer unitaries in an alternating fashion is called Trotterization. It a is a way of approximating the adiabatic pathway.</p>
<div class="section" id="turning-our-unitary-operators-into-gates">
<h3>Turning our Unitary Operators into Gates<a class="headerlink" href="#turning-our-unitary-operators-into-gates" title="Permalink to this headline">¶</a></h3>
<p>To actually create our quantum circuit, we need to be able to express our unitary operators as a series of gates. How do we do that?</p>
<p>First, let’s figure out how to translate are cost unitary to quantum gates. Remember that our cost unitary is <span class="math notranslate nohighlight">\(e^{-i\gamma H_C} = e^{-i\gamma (-\sigma_i^z\sigma_j^zw_{ij})}\)</span></p>
<p>One gate that will be useful is the <span class="math notranslate nohighlight">\(R_z\)</span> gate, which rotates the state around the <span class="math notranslate nohighlight">\(z\)</span> axis of the bloch sphere by an angle <span class="math notranslate nohighlight">\(\frac{\theta}{2}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}R_z(\theta) = e^{-i\frac{\theta}{2}\sigma_z} = 
\cos{\frac{\theta}{2}}I - i\sin{\frac{\theta}{2}}\sigma_z =
\begin{bmatrix} 
e^{-i\frac{\theta}{2}} &amp; 0 \\
0 &amp; e^{i\frac{\theta}{2}}
\end{bmatrix}\end{split}\]</div>
<p>Of course, this is only a one-qubit gate. How do we implement the two-qubit unitary <span class="math notranslate nohighlight">\(e^{-i\frac{\theta}{2}\sigma_i^z\sigma_j^z}\)</span>? One way to see what the effect of this unitary is to observe the effect of applying it to all computational basis states, and replacing the Pauli Z operators with their eigenvalues corresponding to the computational basis states. This slide from Ruslan Shaydulin <a class="reference external" href="https://www.youtube.com/watch?v=AOKM9BkweVU&amp;list=WL&amp;index=21&amp;t=948s">tutorial</a> explains it well: <img alt="Effect of unitary on all computational basis states" src="../_images/gate_mapping.png" /></p>
<p>We can use the CNOT gate to check the parity of qubit <span class="math notranslate nohighlight">\(i\)</span> and qubit <span class="math notranslate nohighlight">\(j\)</span>, then apply our <span class="math notranslate nohighlight">\(R_z\)</span> gate, and then add another CNOT to undo the effect of the first CNOT. The resulting circuit looks like this: <img alt="Cost Unitary Circuit" src="../_images/gate_mapping2.png" />
In this case, <span class="math notranslate nohighlight">\(t\)</span> represents the parameter we pass in (either <span class="math notranslate nohighlight">\(\gamma\)</span> or <span class="math notranslate nohighlight">\(\beta\)</span>). The reason we multiply by two is because the <span class="math notranslate nohighlight">\(R_z(\theta)\)</span> gate rotates by <span class="math notranslate nohighlight">\(\frac{\theta}{2}\)</span>, so multiplying by 2 allows us to rotate by <span class="math notranslate nohighlight">\(\gamma\)</span> or <span class="math notranslate nohighlight">\(\beta\)</span>. Also, since we are solving for weighted graphs, we multiply <span class="math notranslate nohighlight">\(\gamma\)</span> by the weight of the edge. Thus, we end up with an <span class="math notranslate nohighlight">\(R_z(2\gamma w_{ij})\)</span> gate sandwiched between two CNOTs.</p>
<p>Finally, we need to translate our mixer unitary into gates. This one is easy: just as single-qubit <span class="math notranslate nohighlight">\(R_x(2\beta)\)</span> gate. (We’re multiplying by 2 for the same reason we did this for our cost unitary).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Hamiltonians</span>
<span class="k">def</span> <span class="nf">create_cost_unitary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implement the cost unitary on a quantum circuit&quot;&quot;&quot;</span>
    
    <span class="n">cost_unitary</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cost Unitary&quot;</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="c1"># Get weights from graph</span>
    
    <span class="c1"># Add corresponding gates for each edge</span>
    <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">cost_unitary</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">cost_unitary</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="n">weight</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">cost_unitary</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">cost_unitary</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span> <span class="c1"># Visually the unitary for each edge</span>
    <span class="c1">#cost_unitary.to_gate()</span>
    <span class="k">return</span> <span class="n">cost_unitary</span>

<span class="k">def</span> <span class="nf">create_mixer_unitary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implement the mixer unitary on a quantum circuit&quot;&quot;&quot;</span>
    <span class="n">mixer_unitary</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Mixer Unitary&quot;</span><span class="p">)</span>
    
    <span class="c1"># Apply unitary for each node</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span> 
        <span class="n">mixer_unitary</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">mixer_unitary</span><span class="o">.</span><span class="n">to_gate</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mixer_unitary</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="unitary-operator-circuit-demo">
<h3>Unitary Operator Circuit Demo<a class="headerlink" href="#unitary-operator-circuit-demo" title="Permalink to this headline">¶</a></h3>
<p>This is what it would look like if we applied the cost unitary for every edge on our test graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A demonstration of what the cost unitary circuit might look like</span>
<span class="n">test_cost_unitary</span> <span class="o">=</span> <span class="n">create_cost_unitary</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># pi/3 is an arbitrarily chosen angle for demonstration</span>
<span class="n">test_cost_unitary</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/maxcut_10_0.png" src="../_images/maxcut_10_0.png" />
</div>
</div>
<p>And this is what the applying the mixer unitary would look like for each node.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A demonstration of what the mixer unitary circuit might look like</span>
<span class="n">test_mixer_unitary</span> <span class="o">=</span> <span class="n">create_mixer_unitary</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="n">test_mixer_unitary</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/maxcut_12_0.png" src="../_images/maxcut_12_0.png" />
</div>
</div>
<p>Finally, we can create our QAOA circuit. The number of qubits and is the same as the number of nodes in our graph. We start by applying a layer of Hadamard gates to produce our initial superposition state <span class="math notranslate nohighlight">\(|s\rangle\)</span>. Then, we alternate applying our cost and mixer unitaries. Each time we apply a layer of cost and mixer unitaries corresponds to one iteration.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_qaoa_circuit</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create the full QAOA circuit for the graph with the given parameters.&quot;&quot;&quot;</span>
    <span class="n">num_of_iterations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">gammas</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="n">num_of_iterations</span><span class="p">]</span> <span class="c1"># Let the first half of the params list be gamma parameters</span>
    <span class="n">betas</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">num_of_iterations</span><span class="p">:]</span> <span class="c1"># Let the second half of the params list be beta parameters</span>

    <span class="c1"># Initialize Circuit</span>
    <span class="n">qr</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
    <span class="n">cr</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qr</span><span class="p">,</span> <span class="n">cr</span><span class="p">)</span>

    <span class="c1"># Put all qubits in superposition with hadamard gates</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_of_iterations</span><span class="p">):</span>
        <span class="c1"># Get Cost and Mixer Unitaries</span>
        <span class="n">cost_unitary</span> <span class="o">=</span> <span class="n">create_cost_unitary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">gammas</span><span class="p">[</span><span class="n">iteration</span><span class="p">])</span>
        <span class="n">mixer_unitary</span> <span class="o">=</span> <span class="n">create_mixer_unitary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">betas</span><span class="p">[</span><span class="n">iteration</span><span class="p">])</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_unitary</span><span class="p">,</span> <span class="n">qr</span><span class="p">)</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mixer_unitary</span><span class="p">,</span> <span class="n">qr</span><span class="p">)</span>

    <span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qr</span><span class="p">,</span> <span class="n">cr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circuit</span>
  
</pre></div>
</div>
</div>
</div>
<p>Next, we want to find the expectation <span class="math notranslate nohighlight">\(\langle\psi|C|\psi\rangle\)</span> of our QAOA circuit with the state corresponding to the parameters passed in. We can approximate this by taking the results of our quantum circuit and calculating the weighted average of the value of the cut for each bitstring.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_cut_size</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">bit_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the value of the cut associated with a given bitstring,</span>
<span class="sd">    meaning the weighted sum of all of the edges connecting two nodes belonging to opposite subsets.</span>
<span class="sd">    Since the classical optimizer is designed to compute a minimum instead of a maximum,</span>
<span class="sd">    we multiply our cut size by negative one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cut_size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="c1"># Get list of weights for each edge</span>
    
    <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">start_node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">end_node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">bit_string</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bit_string</span><span class="p">[</span><span class="n">end_node</span><span class="p">]:</span>
            <span class="sd">&quot;&quot;&quot;Since the classical optimizer is designed to compute a minimum instead of a maximum,</span>
<span class="sd">            decrement the cut size instead of incrementing it.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">cut_size</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">*</span><span class="n">weight</span>
    <span class="k">return</span> <span class="n">cut_size</span>

<span class="k">def</span> <span class="nf">get_expectation</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the weighted average of the results of the quantum circuit.&quot;&quot;&quot;</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="n">total_executions</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">bit_string</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="n">frequency</span> <span class="o">*</span> <span class="n">get_cut_size</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">bit_string</span><span class="p">)</span>
        <span class="n">total_executions</span> <span class="o">+=</span> <span class="n">frequency</span>
    <span class="k">return</span> <span class="n">energy</span> <span class="o">/</span> <span class="n">total_executions</span> <span class="c1"># Return the average</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we’ll create an array of graphs that we can test our solution on! For the sake of this project, I’ll only run the algorithm on the first graph, but implementing support for an array allows for scalability.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Modifiable constants determining the properties of our list of graphs</span>
<span class="n">NUM_OF_GRAPHS</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">MAX_NUMBER_OF_NODES</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">MAX_WEIGHT</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Create list of graphs to perform QAOA on</span>
<span class="n">graphs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_OF_GRAPHS</span><span class="p">):</span>
    <span class="n">graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_random_connected_graph</span><span class="p">(</span><span class="n">MAX_NUMBER_OF_NODES</span><span class="p">,</span> <span class="n">MAX_WEIGHT</span><span class="p">))</span>

<span class="c1"># Draw Graphs</span>
<span class="k">for</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span> <span class="c1"># Display each graph separately</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/maxcut_18_0.png" src="../_images/maxcut_18_0.png" />
<img alt="../_images/maxcut_18_1.png" src="../_images/maxcut_18_1.png" />
<img alt="../_images/maxcut_18_2.png" src="../_images/maxcut_18_2.png" />
<img alt="../_images/maxcut_18_3.png" src="../_images/maxcut_18_3.png" />
<img alt="../_images/maxcut_18_4.png" src="../_images/maxcut_18_4.png" />
</div>
</div>
</div>
</div>
<div class="section" id="classical-optimization">
<h2>Classical Optimization<a class="headerlink" href="#classical-optimization" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<p>We define an objective function that the SciPy optimizer can find the optimal parameters for. The function returns the expectation of the QAOA circuit. The goal of the optimizer we choose will be to minimize this expectation value.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">CURRENT_GRAPH</span> <span class="o">=</span> <span class="n">graphs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s2">&quot;qasm_simulator&quot;</span><span class="p">)</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">create_qaoa_circuit</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="c1"># Invert bitstrings because Qiskit uses different order</span>
    <span class="k">return</span> <span class="n">get_expectation</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here, we define our initial list of parameters that SciPy will optimize. The length of this list determines the depth of our circuit (how many iterations we want to apply our unitary layers for). We’ll initialize a random set of parameters between 0 and <span class="math notranslate nohighlight">\(\pi\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">NUM_OF_ITERATIONS</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">init_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">NUM_OF_ITERATIONS</span><span class="p">)]</span>

<span class="n">solution</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">init_params</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;COBYLA&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>     fun: -14.68439453125
   maxcv: 0.0
 message: &#39;Optimization terminated successfully.&#39;
    nfev: 70
  status: 1
 success: True
       x: array([4.06844933, 0.15690518, 1.42738659, 0.87646885, 0.29846743,
       3.42030986])
</pre></div>
</div>
</div>
</div>
<p>Now that we’ve found the optimal parameters, let’s plug them into our QAOA circuit and see the results! The spikes on the graph correspond to the best solutions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s2">&quot;qasm_simulator&quot;</span><span class="p">)</span>
<span class="n">optimized_params</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="n">optimal_circuit</span> <span class="o">=</span> <span class="n">create_qaoa_circuit</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">optimized_params</span><span class="p">)</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">optimal_circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="c1"># Invert bitstrings because Qiskit uses different order</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/maxcut_24_0.png" src="../_images/maxcut_24_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Print Counts</span>
<span class="k">for</span> <span class="n">bit_string</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">bit_string</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">frequency</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>000000: 1
100000: 6
000010: 15
100010: 24
010010: 20
110010: 77
001010: 2
101010: 4
011010: 9
111010: 5
000110: 6
100110: 5
010110: 5
110110: 8
101110: 3
011110: 18
111110: 1
010000: 5
000001: 2
100001: 23
010001: 5
001001: 16
101001: 13
011001: 5
111001: 8
000101: 8
100101: 9
010101: 4
001101: 96
101101: 12
011101: 31
111101: 18
110000: 40
000011: 20
100011: 123
010011: 3
110011: 45
001011: 4
101011: 10
011011: 11
111011: 4
000111: 4
010111: 1
110111: 4
001111: 33
101111: 6
011111: 6
001000: 3
011000: 1
111000: 8
000100: 8
100100: 8
010100: 8
110100: 4
001100: 39
101100: 8
011100: 131
111100: 28
</pre></div>
</div>
</div>
</div>
<p>There may be more than one solution. We’ll select the bitstring with the highest frequency as our solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Print the bitstring with the highest frequency</span>
<span class="n">solution_string</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
<span class="n">solution_cut_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">get_cut_size</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">solution_string</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Our solution is &quot;</span> <span class="o">+</span> <span class="n">solution_string</span> <span class="o">+</span> <span class="s2">&quot; with a cut value of &quot;</span> 
      <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">solution_cut_value</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Our solution is 011100 with a cut value of 18.61
</pre></div>
</div>
</div>
</div>
<p>Now let’s visualize our result by coloring the graph!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">color_graph</span><span class="p">(</span><span class="n">bit_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function determines how to color a graph for a given bitstring.&quot;&quot;&quot;</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bit_string</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bit</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">colors</span>

<span class="c1"># Show the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">color_graph</span><span class="p">(</span><span class="n">solution_string</span><span class="p">))</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(1, 3): Text(-0.01674753771946949, 0.28545177409616207, &#39;1.75&#39;),
 (1, 5): Text(0.715466761029708, 0.474791601952659, &#39;2.78&#39;),
 (1, 4): Text(0.3195570920586174, -0.13284077817626752, &#39;2.08&#39;),
 (3, 0): Text(-0.5959727064172196, 0.11181633399969876, &#39;7.07&#39;),
 (0, 2): Text(-0.5873427933094396, -0.367133063241776, &#39;3.65&#39;),
 (0, 5): Text(0.13624159233195787, 0.30115616185619576, &#39;0.03&#39;),
 (2, 4): Text(-0.11949405461248812, -0.5866079359523575, &#39;3.03&#39;)}
</pre></div>
</div>
<img alt="../_images/maxcut_29_1.png" src="../_images/maxcut_29_1.png" />
</div>
</div>
<p>How does this compare to the actual solution? To check, we’ll use a brute force approach to find the solution classically.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compare QAOA Solution to actual solution</span>
<span class="n">all_possibilities</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">bit_string</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">all_possibilities</span><span class="p">[</span><span class="n">bit_string</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_cut_size</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">bit_string</span><span class="p">)</span>

<span class="n">actual_solution</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">all_possibilities</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">all_possibilities</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
<span class="n">actual_solution_cut_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">get_cut_size</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">actual_solution</span><span class="p">)</span> <span class="c1"># Multiply by one to get a positive result</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The actual solution is </span><span class="si">{</span><span class="n">actual_solution</span><span class="si">}</span><span class="s2"> with a cut value of </span><span class="si">{</span><span class="n">actual_solution_cut_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The actual solution is 100011 with a cut value of 18.61
</pre></div>
</div>
</div>
</div>
<p>And finally, let’s visualize the actual solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">color_graph</span><span class="p">(</span><span class="n">actual_solution</span><span class="p">))</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">CURRENT_GRAPH</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(1, 3): Text(0.01604946461088566, 0.2847479650782671, &#39;1.75&#39;),
 (1, 5): Text(-0.7146239765611268, 0.4636686593078169, &#39;2.78&#39;),
 (1, 4): Text(-0.31626451499441, -0.12780905025779288, &#39;2.08&#39;),
 (3, 0): Text(0.5948398177769747, 0.11336473757454996, &#39;7.07&#39;),
 (0, 2): Text(0.5855910738223974, -0.3598274981764227, &#39;3.65&#39;),
 (0, 5): Text(-0.13583362339503774, 0.29228543180409977, &#39;0.03&#39;),
 (2, 4): Text(0.11978415878415191, -0.5770333968823671, &#39;3.03&#39;)}
</pre></div>
</div>
<img alt="../_images/maxcut_33_1.png" src="../_images/maxcut_33_1.png" />
</div>
</div>
<p>So how does our QAOA circuit stack up against brute force, in terms of finding the correct answer? Well, we can use the ratio between the cut value from the QAOA’s answer and the cut value of the correct answer. A higher number means that our QAOA did a better job. For small graphs, we can even get the exact correct answer, resulting in a ratio of 1.0!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">solution_cut_value</span> <span class="o">/</span> <span class="n">actual_solution_cut_value</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0
</pre></div>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Maxcut"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="../teleportation.html" title="previous page">Encoding the quantum state to be teleported.</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By The Jupyter Book community<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>